"use strict";(globalThis.webpackChunkreact_bootstrap_table_ng_website=globalThis.webpackChunkreact_bootstrap_table_ng_website||[]).push([[8709],{1482(e,l,t){t.r(l),t.d(l,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"cell-edit-props","title":"Cell Editing Props","description":"Following we list all props for cellEditFactory from react-bootstrap-table-ng-editor.","source":"@site/docs/cell-edit-props.md","sourceDirName":".","slug":"/cell-edit-props","permalink":"/react-bootstrap-table-ng/docs/cell-edit-props","draft":false,"unlisted":false,"editUrl":"https://github.com/jeff-k-zhou/react-bootstrap-table-ng/tree/main/website/docs/docs/cell-edit-props.md","tags":[],"version":"current","frontMatter":{"id":"cell-edit-props","title":"Cell Editing Props"},"sidebar":"api","previous":{"title":"Columns Props","permalink":"/react-bootstrap-table-ng/docs/column-props"},"next":{"title":"Pagination Props","permalink":"/react-bootstrap-table-ng/docs/pagination-props"}}');var i=t(4848),o=t(8453);const c={id:"cell-edit-props",title:"Cell Editing Props"},r=void 0,s={},a=[{value:"Required",id:"required",level:2},{value:"Optional",id:"optional",level:2},{value:"cellEdit.mode - [String]",id:"celleditmode-string",level:2},{value:"cellEdit.blurToSave - [Bool]",id:"celleditblurtosave-bool",level:2},{value:"cellEdit.nonEditableRows - [Function]",id:"celleditnoneditablerows-function",level:2},{value:"cellEdit.timeToCloseMessage - [Function]",id:"celledittimetoclosemessage-function",level:2},{value:"cellEdit.autoSelectText - [Bool]",id:"celleditautoselecttext-bool",level:2},{value:"cellEdit.beforeSaveCell - [Function]",id:"celleditbeforesavecell-function",level:2},{value:"cellEdit.afterSaveCell - [Function]",id:"celleditaftersavecell-function",level:2},{value:"cellEdit.onStartEdit - [Function]",id:"celleditonstartedit-function",level:2},{value:"cellEdit.errorMessage - [String]",id:"cellediterrormessage-string",level:2},{value:"cellEdit.onErrorMessageDisappear - [Function]",id:"celleditonerrormessagedisappear-function",level:2}];function d(e){const l={a:"a",blockquote:"blockquote",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(l.p,{children:["Following we list all props for ",(0,i.jsx)(l.code,{children:"cellEditFactory"})," from ",(0,i.jsx)(l.a,{href:"https://www.npmjs.com/package/react-bootstrap-table-ng-editor",children:(0,i.jsx)(l.code,{children:"react-bootstrap-table-ng-editor"})}),"."]}),"\n",(0,i.jsx)(l.pre,{children:(0,i.jsx)(l.code,{className:"language-js",children:"import cellEditFactory from 'react-bootstrap-table-ng-editor';\n\nconst cellEdit = cellEditFactory({\n  mode: 'click',\n  ...\n});\n\n`<BootstrapTable` cellEdit={ cellEdit } ... />`\n"})}),"\n",(0,i.jsx)(l.h2,{id:"required",children:"Required"}),"\n",(0,i.jsxs)(l.ul,{children:["\n",(0,i.jsx)(l.li,{children:(0,i.jsxs)(l.a,{href:"#celleditmode-string",children:["mode (",(0,i.jsx)(l.strong,{children:"required"}),")"]})}),"\n"]}),"\n",(0,i.jsx)(l.h2,{id:"optional",children:"Optional"}),"\n",(0,i.jsxs)(l.ul,{children:["\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celleditblurtosave-bool",children:"blurToSave"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celleditnoneditablerows-function",children:"nonEditableRows"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celledittimetoclosemessage-function",children:"timeToCloseMessage"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celleditautoselecttext-bool",children:"autoSelectText"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celleditbeforesavecell-function",children:"beforeSaveCell"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celleditaftersavecell-function",children:"afterSaveCell"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celleditonstartedit-function",children:"onStartEdit"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#cellediterrormessage-string",children:"errorMessage"})}),"\n",(0,i.jsx)(l.li,{children:(0,i.jsx)(l.a,{href:"#celleditonerrormessagedisappear-function",children:"onErrorMessageDisappear"})}),"\n"]}),"\n",(0,i.jsx)(l.hr,{}),"\n",(0,i.jsx)(l.h2,{id:"celleditmode-string",children:"cellEdit.mode - [String]"}),"\n",(0,i.jsxs)(l.p,{children:[(0,i.jsx)(l.code,{children:"cellEdit.mode"})," possible value is ",(0,i.jsx)(l.code,{children:"click"})," and ",(0,i.jsx)(l.code,{children:"dbclick"}),". ",(0,i.jsx)(l.strong,{children:"It's required value"})," that tell ",(0,i.jsx)(l.code,{children:"react-bootstrap-table-ng"})," how to trigger the cell editing."]}),"\n",(0,i.jsx)(l.h2,{id:"celleditblurtosave-bool",children:"cellEdit.blurToSave - [Bool]"}),"\n",(0,i.jsxs)(l.p,{children:["Default is ",(0,i.jsx)(l.code,{children:"false"}),", enable it will be able to save the cell automatically when blur from the cell editor."]}),"\n",(0,i.jsx)(l.h2,{id:"celleditnoneditablerows-function",children:"cellEdit.nonEditableRows - [Function]"}),"\n",(0,i.jsxs)(l.p,{children:[(0,i.jsx)(l.code,{children:"cellEdit.nonEditableRows"})," accept a callback function and expect return an array which used to restrict all the columns of some rows as non-editable. So the each item in return array should be rowkey(",(0,i.jsx)(l.code,{children:"keyField"}),")"]}),"\n",(0,i.jsx)(l.h2,{id:"celledittimetoclosemessage-function",children:"cellEdit.timeToCloseMessage - [Function]"}),"\n",(0,i.jsxs)(l.p,{children:["If a ",(0,i.jsx)(l.a,{href:"./column-props#columnvalidator-function",children:(0,i.jsx)(l.code,{children:"column.validator"})})," defined and the new value is invalid, ",(0,i.jsx)(l.code,{children:"react-bootstrap-table-ng"})," will popup a alert at the bottom of editor. ",(0,i.jsx)(l.code,{children:"cellEdit.timeToCloseMessage"})," is a chance to let you decide how long the alert should be stay. Default is 3000 millisecond."]}),"\n",(0,i.jsx)(l.h2,{id:"celleditautoselecttext-bool",children:"cellEdit.autoSelectText - [Bool]"}),"\n",(0,i.jsxs)(l.p,{children:["Default is false, when enable it, ",(0,i.jsx)(l.code,{children:"react-bootstrap-table-ng"})," will help you to select the text in the text input automatically when editing."]}),"\n",(0,i.jsxs)(l.blockquote,{children:["\n",(0,i.jsxs)(l.p,{children:["NOTE: This props only work for ",(0,i.jsx)(l.code,{children:"text"})," and ",(0,i.jsx)(l.code,{children:"textarea"}),"."]}),"\n"]}),"\n",(0,i.jsx)(l.h2,{id:"celleditbeforesavecell-function",children:"cellEdit.beforeSaveCell - [Function]"}),"\n",(0,i.jsx)(l.p,{children:"This callback function will be called before triggering cell update."}),"\n",(0,i.jsx)(l.pre,{children:(0,i.jsx)(l.code,{className:"language-js",children:"const cellEdit = {\n  // omit...\n  beforeSaveCell: (oldValue, newValue, row, column) => { ... }\n}\n"})}),"\n",(0,i.jsxs)(l.p,{children:["If you want to perform a async ",(0,i.jsx)(l.code,{children:"beforeSaveCell"}),", you can do it like that:"]}),"\n",(0,i.jsx)(l.pre,{children:(0,i.jsx)(l.code,{className:"language-js",children:"const cellEdit: {\n  // omit...\n  beforeSaveCell(oldValue, newValue, row, column, done) {\n    setTimeout(() => {\n      if (confirm('Do you want to accep this change?')) {\n        done(); // contine to save the changes\n      } else {\n        done(false); // reject the changes\n      }\n    }, 0);\n    return { async: true };\n  }\n};\n"})}),"\n",(0,i.jsx)(l.h2,{id:"celleditaftersavecell-function",children:"cellEdit.afterSaveCell - [Function]"}),"\n",(0,i.jsx)(l.p,{children:"This callback function will be called after updating cell."}),"\n",(0,i.jsx)(l.pre,{children:(0,i.jsx)(l.code,{className:"language-js",children:"const cellEdit = {\n  // omit...\n  afterSaveCell: (oldValue, newValue, row, column) => { ... }\n};\n"})}),"\n",(0,i.jsx)(l.h2,{id:"celleditonstartedit-function",children:"cellEdit.onStartEdit - [Function]"}),"\n",(0,i.jsx)(l.p,{children:"This callback function will be called after editor component mounted"}),"\n",(0,i.jsx)(l.pre,{children:(0,i.jsx)(l.code,{className:"language-js",children:"const cellEdit = {\n  // omit...\n  onStartEdit: (row, column, rowIndex, columnIndex) => { ... }\n};\n"})}),"\n",(0,i.jsx)(l.h2,{id:"cellediterrormessage-string",children:"cellEdit.errorMessage - [String]"}),"\n",(0,i.jsxs)(l.p,{children:["This prop is not often used. Only used when you want to keep the error message in your application state and also handle the cell editing on ",(0,i.jsx)(l.a,{href:"./table-props#remote-bool-object",children:(0,i.jsx)(l.code,{children:"remote"})})," mode."]}),"\n",(0,i.jsx)(l.h2,{id:"celleditonerrormessagedisappear-function",children:"cellEdit.onErrorMessageDisappear - [Function]"}),"\n",(0,i.jsx)(l.p,{children:"This callback function will be called when error message discard so that you can sync the newest error message to your state if you have."})]})}function h(e={}){const{wrapper:l}={...(0,o.R)(),...e.components};return l?(0,i.jsx)(l,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,l,t){t.d(l,{R:()=>c,x:()=>r});var n=t(6540);const i={},o=n.createContext(i);function c(e){const l=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(l):{...l,...e}},[l,e])}function r(e){let l;return l=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(o.Provider,{value:l},e.children)}}}]);